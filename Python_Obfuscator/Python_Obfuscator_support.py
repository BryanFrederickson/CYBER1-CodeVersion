#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Mar 05, 2025 02:35:52 PM PST  platform: Windows NT

import tkinter as tk
from tkinter.constants import *
from ScrolledCheckedListBox_PyObfsc import ScrolledCheckedListBox
import tkinter.scrolledtext as st
from tkinter import filedialog
import os
import ast as ast  # for testing validity of Python file
import libcst as cst  # LibCST library for editing source code
from libcst.metadata import (
    MetadataWrapper,
    ParentNodeProvider,
)  # for in-depth cst node parsing
import random  # used for randomly choosing placeholder names
import re  # for regular expressions
import string
from typing_extensions import final
from keyword import iskeyword
from unidecode import unidecode
from coding_abbreviations import abbreviations
import argostranslate.translate
import time
import PyInstaller.__main__

import Python_Obfuscator

_debug = True  # False to eliminate debug printing from callback functions.


def init_params():
    random.seed()
    global params
    params = dict()

    # Customizable Preferences
    # These preferences are encouraged to be tweaked as desired

    params["clones_max"] = 100  # max amount of clones possible to generate at once

    # END Customizable Preferences
    # The preferences below should not be edited to preserve functionality

    params["input_filename"] = ""
    params["input_data"] = ""
    params["output_dir"] = ""
    params["original_cst"] = ""

    params["clones_min"] = 1
    params["clones_count"] = ""
    params["clones_count_valid"] = False

    params["logic_min_percent"] = 0
    params["logic_max_percent"] = 100
    params["logic_percent"] = 0
    params["logic_percent_valid"] = False

    params["func_min_percent"] = 0
    params["func_max_percent"] = 100
    params["func_percent"] = 0
    params["func_percent_valid"] = False

    params["vars_min_percent"] = 0
    params["vars_max_percent"] = 100
    params["vars_percent"] = 0
    params["vars_percent_valid"] = False

    params["lang_names_installed"] = dict()
    params["lang_packages"] = dict()
    params["selected_inputlang"] = ""
    params["selected_outputlangs"] = list()

    global stats
    stats = dict()
    stats["var_name_pairs"] = dict()
    stats["func_name_pairs"] = dict()
    stats["current_outlang"] = "Empty"

    stats["total_vars"] = 0
    stats["changed_vars"] = 0

    stats["total_funcs"] = 0
    stats["changed_funcs"] = 0

    stats["total_logic"] = 0
    stats["changed_logic"] = 0

    stats["curr_translate"] = 0  # holds current clone's translation model

    stats["curr_logfile"] = None

    stats["curr_func_namestyle"] = None
    stats["curr_var_namestyle"] = None
    stats["string_nopunc_model"] = str.maketrans(
        string.punctuation, " " * len(string.punctuation)
    )


def main(*args):
    init_params()
    """Main entry point for the application."""
    global root
    root = tk.Tk()
    root.protocol("WM_DELETE_WINDOW", root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = Python_Obfuscator.Toplevel1(_top1)
    init_langs()
    init_scrolledCheckList()
    bind_entries()
    root.mainloop()


Custom = ScrolledCheckedListBox
Custom2 = st.ScrolledText


def write_to_log(input: str):
    stats["curr_logfile"].write(f"[{time.strftime("%Y-%m-%d %H:%M:%S")}] {input}\n")
    stats["curr_logfile"].flush()  # immediately save to file in case of crash


def print_to_logCurr(input: str):
    _w1.C_logCurr.configure(state="normal")
    _w1.C_logCurr.insert(
        tk.END,
        input + "\n",
    )
    _w1.C_logCurr.see(tk.END)
    _w1.C_logCurr.configure(state="disabled")
    root.update()
    root.after(1)


def clear_logCurr():
    _w1.C_logCurr.configure(state="normal")
    _w1.C_logCurr.delete("1.0", tk.END)
    _w1.C_logCurr.configure(state="disabled")
    root.update()
    root.after(1)


def print_to_logAll(input: str):
    _w1.C_logAll.configure(state="normal")
    _w1.C_logAll.insert(
        tk.END,
        input + "\n",
    )
    _w1.C_logAll.see(tk.END)
    _w1.C_logAll.configure(state="disabled")
    root.update()
    root.after(1)


def update_VarRatio(curr: int, total: int):
    _w1.L_currVarRatio.configure(text=f"{curr}/{total}")
    root.update()
    root.after(1)


def update_FuncRatio(curr: int, total: int):
    _w1.L_currFuncRatio.configure(text=f"{curr}/{total}")
    root.update()
    root.after(1)


def update_LogicRatio(curr: int, total: int):
    _w1.L_currLogicRatio.configure(text=f"{curr}/{total}")
    root.update()
    root.after(1)


def generate_clones():
    _w1.F_generate.tkraise()

    for clone_num in range(params["clones_count"]):
        clear_logCurr()
        print_to_logAll(f"Generating clone #{clone_num+1}...")
        curr_logfile_name = str(f"{params['input_filename'][:-3]}_Obf{clone_num+1}.log")
        curr_logfile_path = os.path.join(params["output_dir"], curr_logfile_name)
        stats["curr_logfile"] = open(curr_logfile_path, mode="w", encoding="utf-8")
        write_to_log("BEGINNING GENERATION...")
        write_to_log(
            f"Parameters: Logic Chance={params['logic_percent']}% Variable Chance={params['vars_percent']}% Function Chance={params['func_percent']}%"
        )

        stats["total_vars"] = 0
        stats["changed_vars"] = 0
        update_VarRatio(0, 0)

        stats["total_funcs"] = 0
        stats["changed_funcs"] = 0
        update_FuncRatio(0, 0)

        stats["total_logic"] = 0
        stats["changed_logic"] = 0
        update_LogicRatio(0, 0)

        ## Provides extra data for every node in the tree ##
        global wrapped_module
        wrapped_module = MetadataWrapper(params["original_cst"])

        if params["vars_percent"] != 0 or params["func_percent"] != 0:
            stats["current_outlang"] = random.choice(params["selected_outputlangs"])
            write_to_log(f"Output language: {stats['current_outlang']}")
            _w1.L_currLang.configure(text=stats["current_outlang"])

            # current translation model equals Input language -> Output Language
            # e.g. model = (English->en->en_package).get_translation(French->fr->fr_package)
            stats["curr_translate"] = params["lang_packages"][
                params["lang_names_installed"][params["selected_inputlang"]]
            ].get_translation(
                params["lang_packages"][
                    params["lang_names_installed"][stats["current_outlang"]]
                ]
            )

        if params["logic_percent"] != 0:
            ## Traverse tree with transformer subclass ##
            write_to_log("OBFUSCATING LOGIC...")
            wrapped_module = wrapped_module.visit(LogicRenamer())
            print_to_logCurr(
                f"Logic Obfuscated: {stats['changed_logic']}/{stats['total_logic']}"
            )
            write_to_log(
                f"Logic Obfuscated: {stats['changed_logic']}/{stats['total_logic']}"
            )

        if params["vars_percent"] != 0:
            stats["var_name_pairs"] = dict()
            stats["curr_var_namestyle"] = random.choice(
                [
                    "camelCase",
                    "PascalCase",
                    "snake_case",
                    "SCREAMING_SNAKE_CASE",
                    "camel_Snake_Case",
                    "Pascal_Snake_Case",
                    "kebab-case",
                    "COBOL-CASE",
                    "Train-Case",
                ]
            )
            write_to_log("RENAMING VARIABLES...")
            write_to_log(
                f"Variable Output Naming Convention: {stats["curr_var_namestyle"]}"
            )
            wrapped_module = wrapped_module.visit(VarRename())
            print_to_logCurr(
                f"Variables Renamed: {stats['changed_vars']}/{stats['total_vars']}"
            )
            write_to_log(
                f"Variables Renamed: {stats['changed_vars']}/{stats['total_vars']}"
            )

        if params["func_percent"] != 0:
            stats["func_name_pairs"] = dict()
            time.sleep(
                0.001
            )  # in case running too fast, avoid same choice as var namestyle
            stats["curr_func_namestyle"] = random.choice(
                [
                    "camelCase",
                    "PascalCase",
                    "snake_case",
                    "SCREAMING_SNAKE_CASE",
                    "camel_Snake_Case",
                    "Pascal_Snake_Case",
                    "kebab-case",
                    "COBOL-CASE",
                    "Train-Case",
                ]
            )
            write_to_log("RENAMING FUNCTIONS...")
            write_to_log(
                f"Function Output Naming Convention: {stats["curr_func_namestyle"]}"
            )
            wrapped_module = wrapped_module.visit(FuncRename())
            print_to_logCurr(
                f"Functions Renamed: {stats['changed_funcs']}/{stats['total_funcs']}"
            )
            write_to_log(
                f"Functions Renamed: {stats['changed_funcs']}/{stats['total_funcs']}"
            )

            write_to_log("RENAMING FUNCTION CALLS...")
            wrapped_module = wrapped_module.visit(CallRename())
            print_to_logCurr("Function calls renamed...")
            write_to_log("Function calls renamed...")

        modified_code = wrapped_module.code
        # [:-3] removes .py extension
        current_filename = str(f"{params['input_filename'][:-3]}_Obf{clone_num+1}.py")
        filepath = os.path.join(params["output_dir"], current_filename)
        write_to_log(
            f"WRITING TO FILE {f"{params['input_filename'][:-3]}_Obf{clone_num+1}.py"}"
        )
        with open(filepath, mode="w", encoding="utf-8") as output_file:
            output_file.write(modified_code)
        output_file.close()
        write_to_log("FILE SUCCESSFULLY WRITTEN")
        print_to_logAll(f"'{current_filename}' generated.\n")

        write_to_log("GENERATING EXECUTABLE...")
        print_to_logAll("Generating executable...")
        folder_dir = os.path.join(
            params["output_dir"],
            str(f"{params['input_filename'][:-3]}_Obf{clone_num+1}"),
        )
        try:
            PyInstaller.__main__.run(
                [
                    filepath,
                    "--onefile",
                    "--distpath",
                    str(params['output_dir']),
                    "--workpath",
                    str(os.path.join(folder_dir, "build")),
                    "--specpath",
                    str(os.path.join(folder_dir, "spec")),
                ]
            )
            write_to_log("EXECUTABLE SUCCESSFULLY GENERATED")
            print_to_logAll("Executable Generated.")
        except Exception as e:
            write_to_log("ERROR GENERATING EXECUTABLE")
            print_to_logAll("Error generating executable!")

        stats["curr_logfile"].close()
    _w1.L_generateStatus.configure(text="Generation Complete.")


def disable_genButton():
    _w1.B_generate.configure(background="#809296")
    _w1.B_generate.configure(disabledforeground="#4c5659")
    _w1.B_generate.configure(state="disabled")
    _w1.B_validate.configure(state="normal")


def init_langs():
    installed_languages = argostranslate.translate.get_installed_languages()
    if not installed_languages:
        _w1.L_transError.configure(
            text='No languages installed. Translation disabled. See "Argos Translate Language Installer" on repo for install guide.'
        )
        _w1.E_transFuncProb.configure(state="disabled")
        _w1.E_transVarProb.configure(state="disabled")
        params["func_percent"] = 0
        params["func_percent_valid"] = True

        params["vars_percent"] = 0
        params["vars_percent_valid"] = True
        _w1.CB_inLang.configure(state="disabled")
    else:
        for lang in installed_languages:
            params["lang_packages"][lang.code] = lang
            params["lang_names_installed"][lang.name] = lang.code

        params["lang_names_installed"] = dict(
            sorted(params["lang_names_installed"].items())
        )
        _w1.CB_inLang.configure(values=list(params["lang_names_installed"].keys()))


def init_scrolledCheckList():
    _w1.C_transOutLangSelect.cback = on_scl_click
    _w1.C_transOutLangSelect.load(list(params["lang_names_installed"].keys()))


def on_scl_click(s=None):
    # ======================================================
    # On event, scrolled frame returns a list containing:
    #    item number selected
    #    text of checkbox selected
    # ======================================================
    # current_count = len(w.C_scrolledChecklist.get())
    # w.L_langsInstallCount.config(text=f"Languages to Install: {current_count}")
    # if current_count > 0:
    # w.B_install.configure(state="normal")
    # else:
    # w.B_install.configure(state="disabled")
    _w1.LF_transOutLangs.configure(
        text=f"Output Languages ({len(_w1.C_transOutLangSelect.get())})"
    )
    disable_genButton()


def bind_entries():
    _w1.E_numClones.bind(
        "<KeyRelease>",
        lambda e: is_int_inrange(
            e.widget,
            "clones_min",
            "clones_max",
            "clones_count",
            "clones_count_valid",
        ),
    )

    #
    #
    # DISABLED LOGIC
    #
    #
    # _w1.L_logicObfscProb.configure(text="Probability: [Disabled]")
    # _w1.E_logicObfscProb.delete(0, END)
    # _w1.E_logicObfscProb.insert(0, "0")
    # _w1.E_logicObfscProb.configure(state="disabled")
    # params['logic_percent'] = 0
    # params['logic_percent_valid'] = True

    _w1.L_logicObfscProbRange.configure(
        text=f"[{params['logic_min_percent']}-{params['logic_max_percent']}]"
    )
    _w1.E_logicObfscProb.bind(
        "<KeyRelease>",
        lambda e: is_int_inrange(
            e.widget,
            "logic_min_percent",
            "logic_max_percent",
            "logic_percent",
            "logic_percent_valid",
        ),
    )

    _w1.L_transFuncRange.configure(
        text=f"[{params['func_min_percent']}-{params['func_max_percent']}]"
    )
    _w1.E_transFuncProb.bind(
        "<KeyRelease>",
        lambda e: is_int_inrange(
            e.widget,
            "func_min_percent",
            "func_max_percent",
            "func_percent",
            "func_percent_valid",
        ),
    )

    _w1.L_transVarRange.configure(
        text=f"[{params['vars_min_percent']}-{params['vars_max_percent']}]"
    )
    _w1.E_transVarProb.bind(
        "<KeyRelease>",
        lambda e: is_int_inrange(
            e.widget,
            "vars_min_percent",
            "vars_max_percent",
            "vars_percent",
            "vars_percent_valid",
        ),
    )

    _w1.CB_inLang.bind("<<ComboboxSelected>>", lambda event: disable_genButton())


# for input entries, shows if input is valid for being an
# integer in specified range
# code adapted from: https://stackoverflow.com/a/60983215
def is_int_inrange(curr_entry, min_val, max_val, curr_val, param_valid):
    disable_genButton()
    try:
        val = int(curr_entry.get().strip())
        validity = params[min_val] <= val <= params[max_val]
        params[curr_val] = val
    except ValueError:
        validity = False
    curr_entry.configure(fg="black" if validity else "red")
    params[param_valid] = validity


def upload_file(event=None):
    params["input_filename"] = ""
    params["input_data"] = ""
    disable_genButton()
    inputpath = filedialog.askopenfilename(
        # initialdir=os.getcwd(),
        initialdir=os.path.dirname(__file__),
        title="Select Python File",
        filetypes=[("Python Source File", "*.py")],
    )
    if inputpath:
        try:
            with open(inputpath, mode="r", encoding="utf-8") as input_file:
                params["input_filename"] = os.path.basename(inputpath)
                params["input_data"] = input_file.read()
                _w1.E_inputFilePath.configure(state="normal")
                _w1.E_inputFilePath.delete(0, tk.END)
                _w1.E_inputFilePath.insert(tk.END, inputpath)
                _w1.E_inputFilePath.configure(state="readonly")
                _w1.E_inputFilePath.xview_moveto(1)
                _w1.L_inputError.configure(text="")
        except Exception:
            _w1.E_inputFilePath.configure(state="normal")
            _w1.E_inputFilePath.delete(0, tk.END)
            _w1.E_inputFilePath.configure(state="readonly")
            _w1.L_inputError.configure(text="Error reading file.")
    else:
        _w1.E_inputFilePath.configure(state="normal")
        _w1.E_inputFilePath.delete(0, tk.END)
        _w1.E_inputFilePath.configure(state="readonly")
        _w1.L_inputError.configure(text="No valid file selected.")


def select_outDir(event=None):
    params["output_dir"] = ""
    disable_genButton()
    out_dir = filedialog.askdirectory(initialdir=os.path.dirname(__file__))
    if out_dir:
        params["output_dir"] = out_dir
        _w1.E_outputDirectory.configure(state="normal")
        _w1.E_outputDirectory.delete(0, tk.END)
        _w1.E_outputDirectory.insert(tk.END, out_dir)
        _w1.E_outputDirectory.configure(state="readonly")
        _w1.E_outputDirectory.xview_moveto(1)
        _w1.L_outputError.configure(text="")
    else:
        _w1.E_outputDirectory.configure(state="normal")
        _w1.E_outputDirectory.delete(0, tk.END)
        _w1.E_outputDirectory.configure(state="readonly")
        _w1.L_outputError.configure(text="No directory selected.")


# used by both validate params button AND generate button
# for generate button, will proceed to generation if still valid
def validate_params():
    # does not immediate return/break when invalid param encountered,
    # tests every param so user can fix all their mistakes at once

    all_params_valid = True

    # leave default error text if it exists, else
    # check params

    # check input params
    if not _w1.L_inputError["text"]:
        if not params["input_data"]:
            _w1.L_inputError.configure(text="Input file empty.")
            all_params_valid = False
            _w1.LF_inputFile.configure(foreground="#d70005")
        else:
            # see if file is syntactically correct
            try:
                ast.parse(params["input_data"])
                _w1.L_valError.configure(font="-family {Segoe UI} -size 9 -weight bold")
                _w1.L_valError.configure(foreground="#000000")
                _w1.L_valError.configure(
                    text=f"{params['input_filename']} is syntactically valid."
                )
                params["original_cst"] = cst.parse_module(params["input_data"])
                _w1.LF_inputFile.configure(foreground="#000000")
            except SyntaxError as error:
                all_params_valid = False
                _w1.L_valError.configure(font="-family {Segoe UI} -size 9 -weight bold")
                _w1.L_valError.configure(foreground="#d70005")
                _w1.L_valError.configure(
                    text=f"Syntax error in {params['input_filename']}: {error}"
                )
                _w1.LF_inputFile.configure(foreground="#d70005")
    elif not params["input_filename"]:
        _w1.LF_inputFile.configure(foreground="#d70005")
        all_params_valid = False
    else:
        _w1.L_inputError.configure(text="")
        _w1.LF_inputFile.configure(foreground="#000000")

    # check output params
    if not _w1.L_outputError["text"]:
        if not params["output_dir"]:
            _w1.LF_outputFiles.configure(foreground="#d70005")
            _w1.L_outputError.configure(text="No directory selected.")
            all_params_valid = False
        elif not params["clones_count_valid"]:
            _w1.L_outputCount.configure(foreground="#d70005")
            _w1.L_outputError.configure(text="Invalid clone count.")
            all_params_valid = False
        else:
            _w1.LF_outputFiles.configure(foreground="#000000")
            _w1.L_outputCount.configure(foreground="#000000")
            _w1.L_outputError.configure(text="")
    elif not params["output_dir"]:
        _w1.LF_outputFiles.configure(foreground="#d70005")
        all_params_valid = False
    else:
        _w1.LF_outputFiles.configure(foreground="#000000")
        _w1.L_outputError.configure(text="")
        _w1.LF_outputFiles.configure(foreground="#000000")
        _w1.L_outputCount.configure(foreground="#000000")
        _w1.L_outputError.configure(text="")

    # check logic obfuscation params
    """
    cannot figure out why logic Obfsc LabelFrame doesn't visually update 
    with the color no matter where in this ENTIRE file I try to call it.
    literally every other label frame works.
    _w1.LF_logicObfsc['foreground']="#d70005" but it doesn't update
    """
    if not params["logic_percent_valid"]:
        _w1.LF_logicObfsc.configure(foreground="#d70005")
        # root.update() # doesn't work either
        # root.after(1)
        _w1.L_logicObfscProb.configure(foreground="#d70005")
        all_params_valid = False
    else:
        _w1.LF_logicObfsc.configure(foreground="#000000")
        _w1.L_logicObfscProb.configure(foreground="#000000")

    # check translation params
    translation_error_full = ""

    if not params["func_percent_valid"]:
        translation_error_full += "Invalid Function probability. "
        _w1.L_transFunc.configure(foreground="#d70005")
        all_params_valid = False
    else:
        _w1.L_transFunc.configure(foreground="#000000")
    if not params["vars_percent_valid"]:
        translation_error_full += "Invalid Variable probability. "
        _w1.L_transVar.configure(foreground="#d70005")
        all_params_valid = False
    else:
        _w1.L_transVar.configure(foreground="#000000")

    valid_probs_butzero = (
        params["func_percent_valid"]
        and params["vars_percent_valid"]
        and params["func_percent"] == 0
        and params["vars_percent"] == 0
    )

    # check translation percentages, because if 0% for both,
    # languages don't need to be selected (see init_langs, if none installed
    # then disable translation)
    # AKA if translation not explicitly disabled, check langs
    if not valid_probs_butzero:
        # check source language
        inlang = _w1.CB_inLang.get()
        if not inlang:
            translation_error_full += "No source language. "
            _w1.LF_transInLang.configure(foreground="#d70005")
            all_params_valid = False
        else:
            params["selected_inputlang"] = inlang
            _w1.LF_transInLang.configure(foreground="#000000")

        # check output languages
        outlangs = _w1.C_transOutLangSelect.get()
        if len(outlangs) == 0:
            translation_error_full += "No output languages. "
            _w1.LF_transOutLangs.configure(foreground="#d70005")
            all_params_valid = False
        elif inlang and (params["selected_inputlang"] in outlangs):
            translation_error_full += "Source language also in output languages. "
            _w1.LF_transOutLangs.configure(foreground="#d70005")
            all_params_valid = False
        else:
            params["selected_outputlangs"] = outlangs.copy()
            _w1.LF_transOutLangs.configure(foreground="#000000")

    _w1.L_transError.configure(text=translation_error_full)

    if all_params_valid:
        # if validated, don't need to validate again, so disabled here,
        # and allow generation
        # when any input param is changed, generate button is disabled
        # and validate button enabled
        _w1.B_generate.configure(background="#70b2c4")
        _w1.B_generate.configure(state="normal")
        _w1.B_generate.configure(activebackground="#63a5b8")
        _w1.B_validate.configure(state="disabled")


def translate_name(input: str, isvar: bool) -> str:
    if iskeyword(input):
        print_to_logCurr(
            f"{'Variable' if isvar else 'Function'} {input} is reserved Python keyword, left unchanged"
        )
        write_to_log(
            f"{'Variable' if isvar else 'Function'} {input} is reserved Python keyword, left unchanged"
        )
        return input
    separate_words = split_name(input)
    unabbrev_sepwords = swap_abbreviations(separate_words)
    spaced_string = "".join(unabbrev_sepwords)

    translated_text = str(stats["curr_translate"].translate(spaced_string))

    nopunc = translated_text.translate(stats["string_nopunc_model"])
    concat_text = concat_name(nopunc, isvar)

    if concat_text.isidentifier():
        output_name = concat_text
    else:
        # attempt transliteration
        transliterated = unidecode(nopunc)
        transliterated = transliterated.translate(stats["string_nopunc_model"])
        transliterated = concat_name(transliterated, isvar)
        if transliterated.isidentifier():
            output_name = transliterated
            print_to_logCurr(
                f"Warning: Translating {'variable' if isvar else 'function'} {input} to {concat_text} failed, transliterated to {transliterated}"
            )
            write_to_log(
                f"Warning: Translating {'variable' if isvar else 'function'} {input} to {concat_text} failed, transliterated to {transliterated}"
            )
        else:
            if isvar:
                output_name = "invalidvar_" + str(stats["changed_vars"])
            else:
                output_name = "invalidfunc_" + str(stats["changed_funcs"])
            print_to_logCurr(
                f"Warning: Transliterating {concat_text} to {transliterated} failed, using placeholder {output_name}"
            )
            write_to_log(
                f"Warning: Transliterating {concat_text} to {transliterated} failed, using placeholder {output_name}"
            )
    print_to_logCurr(
        f"Renamed {'variable' if isvar else 'function'}: {input} -> {output_name}"
    )
    write_to_log(
        f"Renamed {'variable' if isvar else 'function'}: {input} -> {output_name}"
    )
    return output_name


# concats list of object subwords based on a specific naming convention
# input is string of subwords separated by spaces
def concat_name(input: str, isvar: bool) -> str:
    if isvar:
        name_style = stats["curr_var_namestyle"]
    else:
        name_style = stats["curr_func_namestyle"]
    # concat name based on given naming convention style
    output = input
    output = output.strip()

    # camelCase
    if name_style == "camelCase":
        output = output.lower()  # lowercase all
        output = output.title()  # capitalize each word's first char
        output = output[0].lower() + output[1:]  # lowercase first char
        output = output.replace(" ", "")  # remove spaces
        if isvar and (output in (stats["var_name_pairs"]).values()):
            output = output + str(stats["changed_vars"])
        elif not isvar and (output in (stats["func_name_pairs"]).values()):
            output = output + str(stats["changed_funcs"])
    # PascalCase
    elif name_style == "PascalCase":
        output = output.lower()  # lowercase all
        output = output.title()  # capitalize each word's first char
        output = output.replace(" ", "")  # remove spaces
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + str(stats["changed_funcs"])
    # snake_case
    elif name_style == "snake_case":
        output = output.lower()  # lowercase all
        output = output.replace(" ", "_")  # replace spaces with underscores
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_funcs"])
    # SCREAMING_SNAKE_CASE
    elif name_style == "SCREAMING_SNAKE_CASE":
        output = output.upper()  # uppercase all
        output = output.replace(" ", "_")  # replace spaces with underscores
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_funcs"])
    # camel_Snake_Case
    elif name_style == "camel_Snake_Case":
        output = output.lower()  # lowercase all
        output = output.title()  # capitalize each word's first char
        output = output[0].lower() + output[1:]  # lowercase first char
        output = output.replace(" ", "_")  # replace spaces with underscores
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_funcs"])
    # Pascal_Snake_Case
    elif name_style == "Pascal_Snake_Case":
        output = output.lower()  # lowercase all
        output = output.title()  # capitalize each word's first char
        output = output.replace(" ", "_")  # replace spaces with underscores
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "_" + str(stats["changed_funcs"])
    # kebab-case
    elif name_style == "kebab-case":
        output = output.lower()  # lowercase all
        output = output.replace(" ", "-")  # replace spaces with underscores
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "-" + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "-" + str(stats["changed_funcs"])
    # COBOL-CASE
    elif name_style == "COBOL-CASE":
        output = output.upper()  # uppercase all
        output = output.replace(" ", "-")  # replace spaces with underscores
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "-" + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "-" + str(stats["changed_funcs"])
    # Train-Case
    elif name_style == "Train-Case":
        output = output.lower()  # lowercase all
        output = output.title()  # capitalize each word's first char
        output = output.replace(" ", "-")  # replace spaces with underscores
        if isvar and (
            (output in (stats["var_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "-" + str(stats["changed_vars"])
        elif not isvar and (
            (output in (stats["func_name_pairs"]).values()) or iskeyword(output)
        ):
            output = output + "-" + str(stats["changed_funcs"])

    # note that flatcase and UPPERCASE styles could be supported, but they are not parseable
    # as input var/func names, so to ensure output code can be reused, they will not be implemented
    return output


# splits given var/function name into individual words based on naming conventions
def split_name(input: str) -> list:
    # Supported Styles: camelCase, PascalCase, snake_case, SCREAMING_SNAKE_CASE, camel_Snake_Case,
    #                   Pascal_Snake_Case, kebab-case, COBOL-CASE, Train-Case
    # Unsupported Styles (would need a more complex parser e.g. python-wordsegment which only supports english): flatcase, UPPERCASE

    # if not a single letter
    if not len(input) == 1:
        # code based on: https://www.geeksforgeeks.org/python-split-camelcase-string-to-individual-strings/ (method 5)
        # first parse for '_' or '-'
        modified_string = list(map(lambda x: "_" if x == "-" else x, input))
        split_string = "".join(modified_string).split("_")
        sep_words = list(filter(lambda x: x != "", split_string))
        # next check split words for any camelCase or PascalCase, avoiding UPPERCASE and single letters
        # number based strings e.g. 13vals also supported
        i = 0
        # while loop as size of list increases as words broken down
        while i < len(sep_words):
            # if current word not one char and is not all upper or lowercase, split based on capital letters
            if len(sep_words[i]) != 1 and not (
                sep_words[i].isupper() or sep_words[i].islower()
            ):
                modified_string = list(
                    map(lambda x: "_" + x if x.isupper() else x, sep_words[i])
                )
                split_string = "".join(modified_string).split("_")
                sep_subwords = list(filter(lambda x: x != "", split_string))
                # remove unseparated word from larger list
                sep_words.pop(i)
                for k in range(len(sep_subwords)):
                    sep_words.insert(i + k, sep_subwords[k])
            i += 1
        return sep_words
    else:
        return [input]


def swap_abbreviations(input: list) -> list:

    output = []
    for i in range(len(input)):
        curr = input[i].lower()
        if curr in abbreviations:
            for word in (abbreviations[curr]).split():
                output.append(word)
        else:
            output.append(curr)
    return output


## Creation of subclass derived from CSTTransformer which allows modified traversal attributes ##
class VarRename(cst.CSTTransformer):

    ## Allows access to parent node metadata ##
    METADATA_DEPENDENCIES = (ParentNodeProvider,)

    ############ Function to generate a new synonym for the existing variable using gemini API ############

    def get_synonym(self, original_varname):

        ## Only rename the variable if Gemini has not come up with a synonym for it. Otherwise return the current synonym ##
        if original_varname not in stats["var_name_pairs"]:
            stats["total_vars"] = stats["total_vars"] + 1
            time.sleep(0.001)  # in case running too fast
            if random.random() < (float(params["vars_percent"]) * 0.01):
                stats["changed_vars"] = stats["changed_vars"] + 1
                new_name = translate_name(original_varname, True)
                stats["var_name_pairs"][original_varname] = new_name

            else:
                # keep unchanged, add to dict so that it doesn't run this every time an unchanged var is hit
                stats["var_name_pairs"][original_varname] = original_varname
                print_to_logCurr(f"Skipped variable: {original_varname}")
                write_to_log(f"Skipped variable: {original_varname}")
            update_VarRatio(stats["changed_vars"], stats["total_vars"])
        return stats["var_name_pairs"][original_varname]

    #######################################################################################################

    ######################### Function for transforming the 'Param' type Name nodes #######################

    # Context for function: Variable is present within a functiondef or call. ( Ex: function(variable1, variable2) ).

    def leave_Param(
        self, original_node: cst.Param, updated_node: cst.Param
    ) -> cst.Param:

        if isinstance(updated_node.name, cst.Name):

            new_varname = self.get_synonym(updated_node.name.value)
            updated_node = updated_node.with_changes(
                name=updated_node.name.with_changes(value=new_varname)
            )

        return updated_node

    #######################################################################################################

    ######################### Function for transforming the 'For' type Name nodes #########################

    # Context for function: Variable is present within a For statement as a target or iter value. #
    # (Ex: for variable in variable2:)

    def leave_For(self, original_node: cst.For, updated_node: cst.For) -> cst.For:

        if isinstance(updated_node.target, cst.Name):

            new_varname = self.get_synonym(updated_node.target.value)
            updated_node = updated_node.with_changes(
                target=updated_node.target.with_changes(value=new_varname)
            )

        elif isinstance(updated_node.target, cst.Tuple):

            updated_tuple = updated_node.target

            for i, element in enumerate(updated_tuple.elements):

                if isinstance(element.value, cst.Name):

                    new_varname = self.get_synonym(element.value.value)
                    new_element = element.with_changes(
                        value=element.value.with_changes(value=new_varname)
                    )
                    updated_tuple = updated_tuple.with_changes(
                        elements=tuple(updated_tuple.elements[:i])
                        + (new_element,)
                        + tuple(updated_tuple.elements[i + 1 :])
                    )

            updated_node = updated_node.with_changes(target=updated_tuple)

        if isinstance(updated_node.iter, cst.Name):

            new_varname = self.get_synonym(updated_node.iter.value)
            updated_node = updated_node.with_changes(
                iter=updated_node.iter.with_changes(value=new_varname)
            )

        return updated_node

    #######################################################################################################

    ######################### Function for transforming the 'AssignTarget' type Name nodes ################

    # Context for function: Left target value of an assignment operator. (Ex: variable = 5).

    def leave_AssignTarget(
        self, original_node: cst.AssignTarget, updated_node: cst.AssignTarget
    ) -> cst.AssignTarget:

        if isinstance(updated_node.target, cst.Name):

            new_varname = self.get_synonym(updated_node.target.value)
            updated_node = updated_node.with_changes(
                target=updated_node.target.with_changes(value=new_varname)
            )

        return updated_node

    #######################################################################################################

    ######################### Function for transforming the 'Attribute' type Name nodes ###################

    # Context for function:

    def leave_Attribute(
        self, original_node: cst.AssignTarget, updated_node: cst.AssignTarget
    ) -> cst.AssignTarget:

        if (
            isinstance(updated_node.value, cst.Name)
            and updated_node.value.value in stats["var_name_pairs"]
        ):

            new_varname = self.get_synonym(updated_node.value.value)
            return updated_node.with_changes(
                value=updated_node.value.with_changes(value=new_varname)
            )

        if (
            isinstance(updated_node.attr, cst.Name)
            and updated_node.attr.value in stats["var_name_pairs"]
        ):
            new_varname = self.get_synonym(updated_node.attr.value)
            return updated_node.with_changes(
                attr=updated_node.attr.with_changes(value=new_varname)
            )

        return updated_node

    #######################################################################################################

    ######################### Function for transforming the 'Arg' type Name nodes #########################

    # Context for function:

    def leave_Arg(self, original_node: cst.Arg, updated_node: cst.Arg) -> cst.Arg:

        if isinstance(updated_node.value, cst.Name):

            new_varname = self.get_synonym(updated_node.value.value)
            return updated_node.with_changes(
                value=updated_node.value.with_changes(value=new_varname)
            )

        return updated_node

    #######################################################################################################

    """
    ######################### Function for transforming the 'ImportAlias' type Name nodes #################

    # Context for function:

    def leave_ImportAlias(self, original_node: cst.ImportAlias, updated_node: cst.ImportAlias) -> cst.ImportAlias:
        alias_node = updated_node.asname
        if alias_node and alias_node.name.value:
            new_alias = self.get_synonym(alias_node.name.value)
            return updated_node.with_deep_changes(alias_node.name, value=new_alias)
        return updated_node
    #######################################################################################################
    """

    ######################### Function for transforming the 'BinaryOperation' type Name nodes #############

    # Context for function:

    def leave_BinaryOperation(
        self, original_node: cst.BinaryOperation, updated_node: cst.BinaryOperation
    ) -> cst.BinaryOperation:

        if isinstance(updated_node.left, cst.Name):

            new_left_varname = self.get_synonym(updated_node.left.value)
            updated_node = updated_node.with_changes(
                left=updated_node.left.with_changes(value=new_left_varname)
            )

        if isinstance(updated_node.right, cst.Name):

            new_right_varname = self.get_synonym(updated_node.right.value)
            updated_node = updated_node.with_changes(
                right=updated_node.right.with_changes(value=new_right_varname)
            )

        return updated_node

    #######################################################################################################

    """
    ######################### Function for transforming the 'AsName' type Name nodes ######################

    # Context for function:

    def leave_AsName(self, original_node: cst.AsName, updated_node: cst.AsName) -> cst.AsName:

        if isinstance(updated_node.name, cst.Name):

            new_varname = self.get_synonym(updated_node.name.value)
            updated_node = updated_node.with_changes(name=updated_node.name.with_changes(value=new_varname))

        return updated_node
    #######################################################################################################
    """

    ######################### Function for transforming the 'Comparison' type Name nodes ##################

    # Context for function:

    def leave_Comparison(
        self, original_node: cst.Comparison, updated_node: cst.Comparison
    ) -> cst.Comparison:

        if isinstance(updated_node.left, cst.Name):

            new_left_varname = self.get_synonym(updated_node.left.value)
            updated_node = updated_node.with_changes(
                left=updated_node.left.with_changes(value=new_left_varname)
            )

        return updated_node

    #######################################################################################################

    ######################### Function for transforming the 'Return' type Name nodes #######################

    # Context for function:

    def leave_Return(
        self, original_node: cst.Return, updated_node: cst.Return
    ) -> cst.Return:

        if isinstance(updated_node.value, cst.Name):

            new_varname = self.get_synonym(updated_node.value.value)
            updated_node = updated_node.with_changes(
                value=updated_node.value.with_changes(value=new_varname)
            )

        return updated_node

    #######################################################################################################

    def leave_FormattedString(
        self, original_node: cst.FormattedString, updated_node: cst.FormattedString
    ) -> cst.FormattedString:

        new_parts = []

        for part in updated_node.parts:

            if isinstance(part, cst.FormattedStringExpression):

                if isinstance(part.expression, cst.Name):

                    new_varname = self.get_synonym(part.expression.value)
                    new_part = part.with_changes(
                        expression=part.expression.with_changes(value=new_varname)
                    )
                    new_parts.append(new_part)

                else:

                    new_parts.append(part)
            else:

                new_parts.append(part)

        return updated_node.with_changes(parts=new_parts)

    #######################################################################################################


# rename all function defs or aliases (only rename custom functions, not things like print() or math.log)
class FuncRename(cst.CSTTransformer):

    # rename function names in a "def funcname: " node
    # FunctionDef node docs: (https://libcst.readthedocs.io/_/downloads/en/latest/pdf/#page=73&zoom=auto,-205,215)
    def leave_FunctionDef(
        self, node: cst.FunctionDef, updated_node: cst.FunctionDef
    ) -> cst.FunctionDef:
        orig_name = updated_node.name.value
        if orig_name not in stats["func_name_pairs"]:
            stats["total_funcs"] = stats["total_funcs"] + 1
            time.sleep(0.001)  # in case running too fast
            if random.random() < (float(params["func_percent"]) * 0.01):
                stats["changed_funcs"] = stats["changed_funcs"] + 1
                new_name = translate_name(orig_name, False)
                stats["func_name_pairs"].update({orig_name: new_name})

            else:
                stats["func_name_pairs"].update({orig_name: orig_name})
                print_to_logCurr(f"Skipped function def: {orig_name}")
                write_to_log(f"Skipped function def: {orig_name}")
        # the name node in function def is a child node, thus to change function name via the FunctionDef parent node, use with_deep_changes via:
        # (https://libcst.readthedocs.io/en/latest/nodes.html#libcst.CSTNode.with_deep_changes)

        update_FuncRatio(stats["changed_funcs"], stats["total_funcs"])
        # print("Function def of \'"+updated_node.name.value+"\' has been renamed to \'"+stats['func_name_pairs'][updated_node.name.value]+"\'")
        return updated_node.with_deep_changes(
            updated_node.name, value=stats["func_name_pairs"][orig_name]
        )

    # rename function names in a "import x as y" node
    # ImportAlias node docs: (https://libcst.readthedocs.io/_/downloads/en/latest/pdf/#page=78&zoom=auto,-205,314)
    def leave_ImportAlias(
        self, node: cst.ImportAlias, updated_node: cst.ImportAlias
    ) -> cst.ImportAlias:
        alias_node = updated_node.asname
        if alias_node:
            orig_name = alias_node.name.value
            if orig_name not in stats["func_name_pairs"]:
                stats["total_funcs"] = stats["total_funcs"] + 1
                time.sleep(0.001)  # in case running too fast
                if random.random() < (float(params["func_percent"]) * 0.01):
                    stats["changed_funcs"] = stats["changed_funcs"] + 1
                    new_name = translate_name(orig_name, False)
                    stats["func_name_pairs"].update({orig_name: new_name})
                else:
                    stats["func_name_pairs"].update({orig_name: orig_name})
                    print_to_logCurr(f"Skipped function import: {orig_name}")
                    write_to_log(f"Skipped function import: {orig_name}")
            update_FuncRatio(stats["changed_funcs"], stats["total_funcs"])

            # print("Import alias of \'"+alias_node.name.value+"\' has been renamed to \'"+stats['func_name_pairs'][alias_node.name.value]+"\'")
            return updated_node.with_deep_changes(
                updated_node.asname.name,
                value=stats["func_name_pairs"][orig_name],
            )
        return updated_node


# kept separate from FuncRename to do two-pass and prevent renaming predefined functions like print()
class CallRename(cst.CSTTransformer):

    # rename function names in a function call node
    # Call node docs: (https://libcst.readthedocs.io/_/downloads/en/latest/pdf/#page=53&zoom=auto,-205,721)
    def leave_Call(self, node: cst.Call, updated_node: cst.Call) -> cst.Call:

        # Name node: (https://libcst.readthedocs.io/_/downloads/en/latest/pdf/#page=48&zoom=auto,-205,344)
        if (type(updated_node.func)) is cst._nodes.expression.Name:
            if (updated_node.func.value) in stats["func_name_pairs"]:

                # print("Function call of \'"+updated_node.func.value+"\' has been renamed to \'"+stats['func_name_pairs'][updated_node.func.value]+"\'")
                return updated_node.with_deep_changes(
                    updated_node.func,
                    value=stats["func_name_pairs"][updated_node.func.value],
                )

        # for attributes, aka package.function(), only the package can be potentially custom (e.g. 'import math as blah', 'blah.log()')
        # as if you import a subsect and rename it, it will be a normal function call (e.g. 'from math import log as blah', funct call would be
        #                                                                                   'blah()' not 'math.blah()'
        # Attribute node: (https://libcst.readthedocs.io/_/downloads/en/latest/pdf/#page=48&zoom=auto,-205,344)
        elif (type(updated_node.func)) is cst._nodes.expression.Attribute:
            if updated_node.func.value.value in stats["func_name_pairs"]:

                # print("Function call of \'"+updated_node.func.value.value+"."+updated_node.func.attr.value+"\' has been renamed to \'"+stats['func_name_pairs'][updated_node.func.value.value]+"."+updated_node.func.attr.value+"\'")
                return updated_node.with_deep_changes(
                    updated_node.func.value,
                    value=stats["func_name_pairs"][updated_node.func.value.value],
                )
        return updated_node


# Logic renamer subclass definition #
class LogicRenamer(cst.CSTTransformer):

    METADATA_DEPENDENCIES = (
        ParentNodeProvider,
    )  # Allow access to parent node attributes # #

    def leave_While(
        self, original_node: cst.While, updated_node: cst.While
    ) -> cst.For:  # Handles logic swapping for While -> For looping #

        try:
            time.sleep(0.001)  # in case running too fast
            stats["total_logic"] = stats["total_logic"] + 1
            if random.random() < (float(params["logic_percent"]) * 0.01):

                if isinstance(
                    updated_node.test, cst.Comparison
                ):  # If 'while' loop contains any type of logical comparison ( >, <, ==, >=, <=, etc.) #

                    if len(updated_node.test.comparisons) == 1 and isinstance(
                        updated_node.test.comparisons[0].operator, cst.LessThan
                    ):  # Handles < logical comparison #
                        write_to_log("Converted While loop with '<' into For loop")
                        stats["changed_logic"] = stats["changed_logic"] + 1
                        # self.log_change("Converted While loop with '<' into For loop")
                        update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                        return LessThan_Handler(updated_node)

                    if len(updated_node.test.comparisons) == 1 and isinstance(
                        updated_node.test.comparisons[0].operator, cst.GreaterThan
                    ):  # Handles > logical comparison #
                        write_to_log("Converted While loop with '>' into For loop")
                        stats["changed_logic"] = stats["changed_logic"] + 1
                        # self.log_change("Converted While loop with '>' into For loop")
                        update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                        return GreaterThan_Handler(updated_node)

                    update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                    return updated_node

            else:
                update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                return updated_node

        except Exception as e:

            # self.log_change(f"Error in leave_While() <LOGICRENAME>: {str(e)}")
            return original_node

    def leave_If(self, original_node: cst.If, updated_node: cst.If) -> cst.CSTNode:

        try:
            time.sleep(0.001)  # in case running too fast
            stats["total_logic"] = stats["total_logic"] + 1
            if random.random() < (float(params["logic_percent"]) * 0.01):

                transformed_node = If_Handler(updated_node)
                write_to_log("Refactored If-Statement into a function call")
                # self.log_change("Refactored If-Statement into a function call")
                stats["changed_logic"] = stats["changed_logic"] + 1
                update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                return transformed_node

            else:
                update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                return updated_node

        except Exception as e:
            # self.log_change(f"Error in leave_If() <LOGICRENAME>: {str(e)}")
            update_LogicRatio(stats["changed_logic"], stats["total_logic"])
            return original_node

    def leave_For(self, original_node: cst.For, updated_node: cst.For) -> cst.While:

        try:
            time.sleep(0.001)  # in case running too fast
            stats["total_logic"] = stats["total_logic"] + 1
            if random.random() < (float(params["logic_percent"]) * 0.01):

                transformed_node = For_Handler(updated_node)
                write_to_log("Converted For-loop into While-loop")
                stats["changed_logic"] = stats["changed_logic"] + 1
                # self.log_change("Converted For-loop into While-loop")
                update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                return transformed_node

            else:
                update_LogicRatio(stats["changed_logic"], stats["total_logic"])
                return updated_node

        except Exception as e:

            # self.log_change(f"Error in leave_For() <LOGICRENAME>: {str(e)}")
            update_LogicRatio(stats["changed_logic"], stats["total_logic"])
            return original_node


# Logic for swapping Less Than symbols in While loops #
def LessThan_Handler(self, updated_node):

    try:

        if isinstance(updated_node.test.left, cst.Name):

            loop_var = updated_node.test.left  # Assigns to var if on LHS of operator #
            num_bound = updated_node.test.comparisons[
                0
            ].comparator  # Assigns to integer that terminates loop #

            # Return new CST module structure back into the original CST #
            return cst.For(
                target=loop_var,
                iter=cst.Call(
                    func=cst.Name("range"),
                    args=[cst.Arg(loop_var), cst.Arg(num_bound)],
                ),
                body=updated_node.body,
                orelse=updated_node.orelse,
            )

    except Exception as e:

        # self.log_change(f"Error in LessThan_Handler() <LOGICRENAME>: {str(e)}")
        return updated_node


# Logic for swapping Greater Than symbols in While loops #
def GreaterThan_Handler(self, updated_node):

    try:

        if isinstance(updated_node.test.left, cst.Name):

            loop_var = updated_node.test.left  # Assigns to var if on LHS of operator #
            num_bound = updated_node.test.comparisons[
                0
            ].comparator  # Assigns to integer that terminates loop #
            step = step = cst.UnaryOperation(
                operator=cst.Minus(), expression=cst.Integer("1")
            )  # Set increment value #

            # Return new CST For loop module back into the original CST #
            return cst.For(
                target=loop_var,
                iter=cst.Call(
                    func=cst.Name("range"),
                    args=[
                        cst.Arg(loop_var),
                        cst.Arg(num_bound),
                        cst.Arg(step),
                    ],
                ),
                body=updated_node.body,
                orelse=updated_node.orelse,
            )

    except Exception as e:

        # self.log_change(f"Error in GreaterThan_Handler() <LOGICRENAME>: {str(e)}")
        return updated_node


# Logic for swapping if statements with function def and call #
def If_Handler(self, updated_node):

    try:

        func_name = "function"  # Defines the name of the function which calls original if statement #

        # Creation of function definition node #
        func_def = cst.FunctionDef(
            name=cst.Name(func_name),
            params=cst.Parameters(),
            body=cst.IndentedBlock(body=[updated_node]),
        )

        # Creation of explicit function call node #
        func_call = cst.Expr(
            value=cst.Call(
                func=cst.Name(func_name),
                args=[],
                whitespace_after_func=cst.SimpleWhitespace(""),
            )
        )

        # Returns multiple nodes which consist of both a function def and a function call #
        return cst.FlattenSentinel([func_def, func_call])

    except Exception as e:

        # self.log_change(f"Error in If_Handler() <LOGICRENAME>: {str(e)}")
        return updated_node


# Logic for swapping For loops to While loops encountered while traversing CST #
def For_Handler(self, updated_node):

    try:

        loop_var = updated_node.target  # Variable within For loop #

        loop_args = updated_node.iter.args  # List of loop arguments #
        start = loop_args[0].value  # Starting integer condition #
        stop = loop_args[1].value  # Ending integer condition #

        if len(loop_args) == 3:
            step = loop_args[2].value
        else:

            if isinstance(start, cst.Integer) and isinstance(stop, cst.Integer):
                step_value = "-1" if int(start.value) > int(stop.value) else "1"
                step = cst.Integer(step_value)
            else:
                step = cst.Integer("1")

        operation = (
            cst.LessThan()
            if (isinstance(step, cst.Integer) and int(step.value) > 0)
            else cst.GreaterThan()
        )  # Type of operation (+,-,>,<, etc.) #

        # Creation of While loop node #
        while_loop = cst.While(
            test=cst.Comparison(
                left=loop_var,
                comparisons=[cst.ComparisonTarget(operator=operation, comparator=stop)],
            ),
            body=updated_node.body,
            orelse=updated_node.orelse,
        )

        # Creation of variable increment line living within while loop #
        increment = cst.SimpleStatementLine(
            body=[
                cst.Assign(
                    targets=[cst.AssignTarget(target=loop_var)],
                    value=cst.BinaryOperation(
                        left=loop_var, operator=cst.Add(), right=step
                    ),
                )
            ]
        )

        updated_body = list(while_loop.body.body) + [increment]
        while_loop = while_loop.with_changes(body=cst.IndentedBlock(body=updated_body))

        return cst.FlattenSentinel([while_loop])

    except Exception as e:

        # self.log_change(f"Error in For_Handler() <LOGICRENAME>: {str(e)}")
        return updated_node


if __name__ == "__main__":
    Python_Obfuscator.start_up()
